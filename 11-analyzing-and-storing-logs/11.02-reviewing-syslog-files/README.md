## Цели

После завершения этого раздела вы сможете интерпретировать события в соответствующих файлах syslog для устранения проблем и просмотра состояния системы.

## Протоколирование событий в системе

Многие программы используют syslog для протоколирования событий в системе. Каждое сообщение классифицируется по источнику (тип сообщения) и приоритету (важность сообщения). Информация о доступных источниках приведена на man-странице `rsyslog.conf(5)`.

В следующей таблице указаны восемь стандартных приоритетов syslog, от самого высокого до самого низкого.

**Таблица 11.2.1. Обзор приоритетов syslog**

| Код | Приоритет | Приоритет |
| --- | --- | --- |
| 0   | emerg | Систему невозможно использовать |
| 1   | alert | Необходимо немедленно принять меры |
| 2   | crit | Критическое состояние |
| 3   | err | Некритическое состояние ошибки |
| 4   | warning | Предупреждение |
| 5   | notice | Обычное событие повышенной важности |
| 6   | info | Информационное событие |
| 7   | debug | Отладочное сообщение |


Служба **rsyslog** использует источник и приоритет сообщений журнала для определения способа их обработки. Настройка сортировки сообщений осуществляется с помощью правил в файле **/etc/rsyslog.conf** и в любом файле с расширением **.conf** в каталоге **/etc/rsyslog.d**. Программные пакеты могут легко добавлять правила, устанавливая соответствующие файлы в каталог **/etc/rsyslog.d**.

Каждое правило, управляющее сортировкой сообщений syslog, представляет собой строку в одном из файлов конфигурации. В левой части каждой строки указаны источник и приоритет сообщений syslog, соответствующих правилу. Правая часть каждой строки указывает, в каком файле сохранять сообщение (или куда его доставить). Звездочка (`*`) — это метасимвол, который соответствует всем значениям.

Например, следующая строка записывает сообщения, отправленные источнику **authpriv** с любым приоритетом, в файл **/var/log/secure**:

```
authpriv.*                  /var/log/secure
```

Иногда сообщения журнала могут соответствовать нескольким правилам, указанным в файле **rsyslog.conf**. В таких случаях одно сообщение хранится в нескольких log-файлах. Чтобы ограничить количество сохраняемых сообщений, задайте в поле приоритета ключевое слово none, которое указывает, что никакие сообщения для указанного источника не должны сохраняться в данном файле.

Вместо того чтобы сохранять сообщения syslog в файле, их можно выводить на терминалы всех пользователей, вошедших в систему. В файле **rsyslog.conf** есть настройки для вывода всех сообщений syslog с приоритетом emerg на терминалы всех пользователей, вошедших в систему.

Примеры правил rsyslog

```
#### RULES ####

# Log all kernel messages to the console.
# Logging much else clutters up the screen.
#kern.*                                                 /dev/console

# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
*.info;mail.none;authpriv.none;cron.none                /var/log/messages

# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure

# Log all the mail messages in one place.
mail.*                                                  -/var/log/maillog


# Log cron stuff
cron.*                                                  /var/log/cron

# Everybody gets emergency messages
*.emerg                                                 :omusrmsg:*

# Save news errors of level crit and higher in a special file.
uucp,news.crit                                          /var/log/spooler

# Save boot messages also to boot.log
local7.*                                                /var/log/boot.log
```

<details>
<summary>Примечание</summary>

Подсистема syslog предоставляет множество других возможностей, которые не рассматриваются в этом курсе. Дополнительные сведения на эту тему можно найти на man-странице `rsyslog.conf(5)`, а также в обширной HTML-документации, содержащейся в файле **/usr/share/doc/rsyslog/html/index.html** пакета rsyslog-doc, который доступен в репозитории AppStream систем на базе RHEL.
</details>

## Ротация log-файлов

Утилита `logrotate` осуществляет ротацию log-файлов, чтобы они не заполнили все свободное пространство в файловой системе, содержащей каталог **/var/log**. При ротации log-файла к его имени добавляется дата ротации. Например, старый файл **/var/log/messages** может получить имя **/var/log/messages-20190130** при ротации 30 января 2019 г. После ротации старого файла создается новый log-файл и служба, осуществляющая запись в этот файл, получает уведомление.

После определенного количества ротаций (обычно через 4 недели) самый старый log-файл удаляется для освобождения дискового пространства. Запланированное задание ежедневно запускает программу `logrotate`, чтобы определить необходимость ротации log-файлов. Ротация большинства log-файлов выполняется еженедельно, однако программа `logrotate` выполняет ротацию некоторых файлов быстрее, медленнее или по достижении файлами определенного размера.

Конфигурация программы `logrotate` не рассматривается в этом курсе. Дополнительные сведения см. на man-странице `logrotate(8)`.

## Анализ записи syslog

Сообщения в log-файлах начинаются с самого старого сообщения вверху и заканчиваются самым последним сообщением внизу. Служба rsyslog использует стандартный формат при записи сообщений в log-файлы. В следующем примере объясняется структура сообщения в log-файле **/var/log/secure**.

![](assets/11.2.1.svg)

|     |     |
| --- | --- |
| 1   | Метка времени создания записи в log-файле |
| 2   | Хост, с которого было отправлено сообщение журнала |
| 3   | Имя и идентификатор PID программы или процесса, которые отправили сообщение журнала |
| 4   | Содержание отправленного сообщения |

## Мониторинг log-файлов

Чтобы иметь возможность воспроизвести проблемные ситуации и ошибки, рекомендуется периодически просматривать события в одном или нескольких log-файлах. Команда `tail -f /path/to/file` выводит последние 10 строк указанного файла и продолжает выводить новые строки в файл по мере их записи.

Например, для отслеживания неудачных попыток входа в систему выполните команду `tail` на одном терминале, а затем на другом терминале выполните команду `ssh` от имени пользователя root, пока пользователь пытается войти в систему.

В окне первого терминала выполните следующую команду `tail`:

```
[root@host ~]# tail -f /var/log/secure
```

В окне второго терминала выполните следующую команду `ssh`:

```
[root@host ~]# ssh root@localhost
root@localhost's password: redhat
...output omitted...
[root@host ~]# 
```

Вернитесь к первому терминалу и просмотрите сообщения журналов.

```
...output omitted...
Feb 10 09:01:13 host sshd[2712]: Accepted password for root from 172.25.254.254 port 56801 ssh2
Feb 10 09:01:13 host sshd[2712]: pam_unix(sshd:session): session opened for user root by (uid=0)
```

## Отправка сообщений syslog вручную

Команда `logger` может отправлять сообщения службе rsyslog. По умолчанию она отправляет сообщение источнику **user** с приоритетом **notice** (**user.notice**), если иное не указано с помощью опции `-p`. Полезно проверять все изменения в конфигурации службы rsyslog.

Чтобы отправить сообщение службе rsyslog, которое записывается в log-файл **/var/log/boot.log**, выполните следующую команду `logger`:

```
[root@host ~]# logger -p local7.notice "Log entry created on host"
```